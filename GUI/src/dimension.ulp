/*Function to get path to folder with project which is now opened.*/
string get_project_path() 
{
  if (board)     board(B)     return(filedir(B.name));
  if (schematic) schematic(S) return(filedir(S.name));
  if (library)   library(L)   return(filedir(L.name));
}

// variable represents the output filename.
string outputFileName = get_project_path() + "/" +"experiment.txt";

/*
DESCRIPTION: Scans a string and replaces douple quotes (") with a space character. This is needed
             so that the resulting JSON file is valid. Without this check the resulting JSON
             could include double quotes embedded in a  part and the resulting JSON is invalid
             which will make iBOM not work. 
*/
string removeDoubleQuote(string passedString)
{
    for (int i = 0; passedString[i]; ++i) 
    {    
        if(passedString[i] == '\"')
        {
            passedString[i] = ' ';
        }
    }
    return passedString;
}



void PrintArcToFile(UL_WIRE W, int ranOnce)
{
    if(ranOnce)
    {
        printf(",\n");
    }
    // See PCB_Data_Format.md" for description of a segment of type arc.
    printf("\t{\n");
    // arc type
    printf("\t\t\"type\" : \"arc\",\n");
    printf("\t\t\"start\": [%5.5f,%5.5f],\n",u2mm(W.arc.x1),u2mm(W.arc.y1));
    printf("\t\t\"end\"  : [%5.5f,%5.5f],\n",u2mm(W.arc.x2),u2mm(W.arc.y2));
    printf("\t\t\"center\"  : [%5.5f,%5.5f],\n",u2mm(W.arc.xc), u2mm(W.arc.yc));
    printf("\t\t\"radius\": %5.5f,\n",u2mm(W.arc.radius));
    printf("\t\t\"width\": %5.5f\n", u2mm(W.arc.width));
    printf("\t}");
}

void PrintLineToFile(UL_WIRE W, int ranOnce)
{
    if(ranOnce)
    {
        printf(",\n");
    }
    // See PCB_Data_Format.md" for description of a segment of type line.
    printf("\t{\n");
    printf("\t\t\"type\" : \"line\",\n");
    printf("\t\t\"start\": [%5.5f,%5.5f],\n",u2mm(W.x1),u2mm(W.y1));
    printf("\t\t\"end\"  : [%5.5f,%5.5f],\n",u2mm(W.x2),u2mm(W.y2));
    printf("\t\t\"width\": %5.5f\n", u2mm(W.width));
    printf("\t}");
}

void PrintCircleToFile(UL_CIRCLE C, int ranOnce)
{
    if(ranOnce)
   {
        printf(",\n");
    }

    // See PCB_Data_Format.md" for description of a segment of type circle.
    printf("\t{\n");
    // circle type
    printf("\t\t\"type\" : \"circle\",\n");
    // center point
    printf("\t\t\"center\"  : [%5.5f,%5.5f],\n",u2mm(C.x), u2mm(C.y));
    // radius
    printf("\t\t\"radius\": %5.5f,\n",u2mm(C.radius));
    // line width
    printf("\t\t\"width\": %5.5f\n", u2mm(C.width));
    printf("\t}");
}

void PrintRectangleToFile(UL_RECTANGLE R, int ranOnce)
{
    // TODO: Add support for rectangle
}

void PrintPolygonToFile(UL_POLYGON P, int ranOnce)
{
    // TODO: Add support for rectangles.
}

/*
    Define entry for PCB dimensions. This will write to the output file entries for each 
    wire that makes up the output board.
*/
void GenerateDimensions( void )
{
    // This variable is used to make sure that the extra ',' characters is not printed
    // after the last }, as this will make the json invalid and python wont import the file then.
    int ranOnce = 0;
    // Board is of type UL_BOARD. This creates a variable, B that represents the board context.
    board(B)
    {
        // Print to the file the start of the edges section. This will be an array of wire segments
        printf("\"board_shape\": [\n");
        // Iterate over all circles on the board. 
        B.circles(C) 
        {
            if(C.layer == LAYER_DIMENSION)
            {
                PrintCircleToFile(C, ranOnce);
                ranOnce = 1;
            }
        }
        // Iterate over every wire on the pcb board. 
        /*
            Eagle treats wires and arcs as almost the same thing. Some extra cheks need to 
            be performed to make sure that a line s a line ad not an arc. See ULP manual 
            page 76.
        */
        B.wires(W)
        {
            /* 
                Check if the wire is on the dimension layer. If the wire is on the dimension layer then
                add a segment object to the output file. 

                The start and end points of the wire segment need to be converted to be in millimeters.
                The type will always be set to segment since the assumption is that the board dimension
                is set using wire segments.

                The widths is the size of the wire.
            */
            if(W.layer == LAYER_DIMENSION)
            {
                /*
                    Checks are now performed to see if the line is a line or a line is a arc. 
                    Depending on the result, a different style of processing needs to be done.
                */
                if(W.arc) // False if not an arc
                {
                    PrintArcToFile(W, ranOnce);
                    ranOnce = 1;
                }
                else // must be a wire
                {
                    PrintLineToFile(W, ranOnce);
                    ranOnce = 1;
                }
                
            }
        }
        printf("\n]\n");
    }
}


void GenerateTopSilkscreen( void )
{
    // This variable is used to make sure that the extra ',' characters is not printed
    // after the last }, as this will make the json invalid and python wont import the file then.
    int ranOnce = 0;

    // Board is of type UL_BOARD. This creates a variable, B that represents the board context.
    board(B)
    {
        // Print to the file the start of the edges section. This will be an array of wire segments
        printf("\"silkscreen_top\": [\n");

        B.elements(E)
        {
            E.package.wires(W)
            {
                if (W.arc)
                {
                    if (W.layer == LAYER_TPLACE)
                    {
                        PrintArcToFile(W, ranOnce);
                        ranOnce = 1;
                    }
                }
                else
                {
                    if (W.layer == LAYER_TPLACE) 
                    {
                        PrintLineToFile(W, ranOnce);
                        ranOnce = 1;
                    }
                }
            }

            E.package.circles(C)
            {
                if (C.layer == LAYER_TPLACE)
                {
                    PrintCircleToFile(C, ranOnce);
                    ranOnce = 1;
                }
            }

            E.package.rectangles(R)
            {
                if (R.layer == LAYER_TPLACE) 
                {
                    PrintRectangleToFile(R, ranOnce);
                    ranOnce = 1;
                }
            }

            E.package.polygons(P)
            {
                if (P.layer == LAYER_TPLACE ) 
                {
                    PrintPolygonToFile(P,ranOnce);
                    ranOnce = 1;
                }
            }

            E.package.texts(T)
            {
                if (T.layer == LAYER_TPLACE)
                {
                    
                }
            }

            E.package.texts(T)
            {
                if(T.layer == LAYER_TPLACE)
                {
                    T.wires(W)
                    {
                        if(W.arc) // False if not an arc
                        {
                            PrintArcToFile(W,ranOnce);
                            ranOnce = 1;
                        }
                        else // must be a wire
                        {
                            PrintLineToFile(W, ranOnce);
                            ranOnce = 1;
                        }
                    }
                }
            }
        }

        B.texts(T)
        {
            if(T.layer == LAYER_TPLACE)
            {
                T.wires(W)
                {
                    if(W.arc) // False if not an arc
                    {
                        PrintArcToFile(W,ranOnce);
                        ranOnce = 1;
                    }
                    else // must be a wire
                    {
                        PrintLineToFile(W, ranOnce);
                        ranOnce = 1;
                    }
                }
            }
        }
        printf("\n]\n");
    }
}


void GenerateModuleData(void)
{
    int ranOnceInner = 0;
    int ranOnceOuter = 0;
    board(B)
    {
        printf("\"modules\": {\n");

        B.elements(E)
        {
            if(ranOnceOuter)
            {
                printf("},\n");
            }
            printf("\"%s\": {\n",removeDoubleQuote(E.name));
            printf("\"pads\":[\n");
            E.package.contacts(C)
            {
                if(ranOnceInner)
                {
                    printf(",\n");
                }
                printf("{\n");
                if(C.smd)
                {
                    printf("\"angle\": %5.5f,\n",C.smd.angle);
                }
                else if(C.pad)
                {
                    printf("\"angle\": %5.5f,\n",C.pad.angle);
                }
                // Checks if the part is smd or through hole.
                if(C.smd)
                {
                    if(!E.mirror)
                    {
                        printf("\"layers\":\"F\",\n");
                    }
                    else
                    {
                        printf("\"layers\":\"B\",\n");
                    }
                }
                else if(C.pad)
                {
                   printf("\"layers\":\"FB\",\n");
                }

                printf("\"pos\": [%5.5f,%5.5f],\n",u2mm(C.x), u2mm(C.y));
                if(C.smd)
                {
                    printf("\"roundness\": %d,\n", C.smd.roundness);
                }
                else
                {
                    printf("\"roundness\": 0,\n");
                }
                
                if(C.smd)
                {
                    printf("\"size\": [%5.5f,%5.5f],\n",u2mm(C.smd.dx), u2mm(C.smd.dy));
                    printf("\"type\": \"smd\"\n");
                }
                else if(C.pad)
                {
                    printf("\"size\": [%5.5f,%5.5f],\n",1.0, 1.0);
                    printf("\"type\": \"smd\"\n");
                }
                printf("}\n");
                ranOnceInner = 1;
            }
            printf("]\n");
            ranOnceInner = 0;
            ranOnceOuter = 1;
        }
        printf("}\n");
        printf("}\n");
    }
}



/*
    Add the section for the bounding box. The bounding box is created by looking at the min and max 
    x and y values for the board. The min and max values are defined as the lower left and upper 
    right points that form a box that encapsulates the entire pcb. 
*/
void GenerateBoundingBox( void )
{
    board(B) {
        // Print the edge_box segment to the output file
        printf("\"pcb_bounding_box\": {\n");
        /*
            The min and max values are set by looking at the area parameter of the board. The units 
            need to be converted to millimeters. 

            ASSUMPTION. The pcb lower left corner is also the pcb origin. 
        */
        //TODO: Comparison to select what the min and max values are. This way the lower left corner 
        //      does not need to be the origin.
        printf("\t\t\"maxx\": \"%5.5f\",\n", u2mm(B.area.x1));
        printf("\t\t\"maxy\": \"%5.5f\",\n", u2mm(B.area.y1));
        printf("\t\t\"minx\": \"%5.5f\",\n", u2mm(B.area.x2));
        printf("\t\t\"miny\": \"%5.5f\"\n", u2mm(B.area.y2));
        printf("}\n");
    }
}

output(outputFileName,"w")
{
    printf("{\n");
    GenerateDimensions();
    printf(",\n");
    GenerateTopSilkscreen();
    printf(",\n");
    GenerateModuleData();
    printf(",\n");
    GenerateBoundingBox();
    printf("}\n");
}