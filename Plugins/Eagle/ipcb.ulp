
/***************************************************************************************************
                                         USAGE DECLERATION
***************************************************************************************************/
#usage "en: Interactive PCB Data Generator ULP\n"
           "Implements a generator that extracts needed data from a board file \n"
           "and creates the JavaScript JSON variable that is needed for interactive PCB \n"
           "to function\n\n"
           "Usage: RUN ipcb.ulp\n"
           "Author: Sean Alling"
/**************************************************************************************************/



/***************************************************************************************************
                                         GLOBAL DATA
***************************************************************************************************/
string dirName;

unsigned PROTOCOL_VERSION = 2;

/*Function to get path to folder with project which is now opened.*/
string get_project_path()
{
  if (board)     board(B)     return(filedir(B.name));
  if (schematic) schematic(S) return(filedir(S.name));
  if (library)   library(L)   return(filedir(L.name));
}

if (dlgMessageBox("Do you want to select output directory? If you select \"No\", JSON file will be saved to project directory.", "&Yes", "&No") == 0)
{
   dirName = dlgDirectory("Select a directory", "");

}
else
{
   dirName = get_project_path();
}


string outputFileName = dirName + "/" +"pcbdata.json";

string layerNames[];




/**************************************************************************************************/





/**************************************************************************************************/
/********************                    COMMON DEFINITIONS                    ********************/
/**************************************************************************************************/

/******************** SEGMENT DEFINITIONS ********************/

/********** PATH DEFINITIONS **********/
void Print_Segment_Path_Line(string layerName, real x0, real y0, real x1, real y1, real width)
{
    printf(   "{\"type\":\"line\",\"layer\":\"%s\",\"x0\":%5.5f,\"y0\":%5.5f,\"x1\":%5.5f,\"y1\":%5.5f,\"width\":%5.5f}"
            , layerName
            , x0
            , y0
            , x1
            , y1
            , width
          );
}

void Print_Segment_Path_Arc(string layerName, real x0, real y0, real radius, real angle0, real angle1, real width)
{
    printf(   "{\"type\":\"arc\",\"layer\":\"%s\",\"cx0\":%5.5f,\"cy0\":%5.5f,\"radius\":%5.5f,\"angle0\":%5.5f,"\"angle1\":%5.5f,\"width\":%5.5f,\"direction\":\"clockwise\"}"
            , layerNames
            , x0
            , y0
            , radius
            , angle0
            , angle1
            , width
        );
}

/********** POLYGONS DEFINITIONS **********/
void Print_Segment_Path_Polygon(void)
{
    //<POLYGON>          ::= "{" "\"type\"" ":" "\"polygon\"" "," "\"layer\":" <STRING> "," "\"positive\"" ":" <POLYGON_DIRECTION> "," "\"segments\"" ":" "[" <PATHS> "]" "}"
}



/********** VIA DEFINITIONS **********/
void Print_Segment_VIA_Round(string layerName,real x, real y, real diameter, real drill)
{
    Print_Segment_Via("via_round", layerName, x, y, diameter, drill);
}

void Print_Segment_VIA_Square(string layerName,real x, real y, real diameter, real drill)
{
    Print_Segment_Via("via_square", layerName, x, y, diameter, drill);
}

void Print_Segment_VIA_Octogon(string layerName, real x, real y, real diameter, real drill)
{
    Print_Segment_Via("via_octagon", layerName, x, y, diameter, drill);
}

void Print_Segment_Via(string viaType, string layerName, real x, real y, real diameter, real drill)
{
    printf(   "{\"type\":\"$s\",\"layer\":\"%s\",\"x\":%5.5f,\"y\":%5.5f,\"diameter\":%5.5f,\"drill\":%5.5f}"
            , layerName
            , x
            , y
            , diameter
            , drill
          );
}

void Print_BoundingBox(real x0, real y0, real x1, real y1)
{

    // Print the edge_box segment to the output file
    printf("\"bounding_box\":{");
    printf("\"x0\":%5.5f,", u2mm(E.package.area.x1));
    printf("\"y0\":%5.5f,", u2mm(E.package.area.y1));
    printf("\"x1\":%5.5f,", u2mm(E.package.area.x2));
    printf("\"y1\":%5.5f" , u2mm(E.package.area.y2));
    printf("}");

    printf(   "\"bounding_box\":{\"x0\":%5.5f,\"y0\":%5.5f,\"x1\":%5.5f,\"y1\":%5.5f}"
            , x0
            , y0
            , x1
            , y1
          );
}

// Eagle color codes are ARGB
// iPCB expects them in RGBA.
char hex_characters[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
string PalletColorToHTMLString(int colorCode_ARGB)
{
    int A = ((colorCode_ARGB >> 24) & 0xFF);
    int R = ((colorCode_ARGB >> 16) & 0xFF);
    int G = ((colorCode_ARGB >>  8) & 0xFF);
    int B = ((colorCode_ARGB >>  0) & 0xFF);

    string str="#";
    str += hex_characters[(R>>4) & 0xF];
    str += hex_characters[(R>>0) & 0xF];
    str += hex_characters[(G>>4) & 0xF];
    str += hex_characters[(G>>0) & 0xF];
    str += hex_characters[(B>>4) & 0xF];
    str += hex_characters[(B>>0) & 0xF];
    str += hex_characters[(A>>4) & 0xF];
    str += hex_characters[(A>>0) & 0xF];


    return str;
}

/**************************************************************************************************/
/********************                   METADATA DEFINITIONS                   ********************/
/**************************************************************************************************/
    void Print_Metadata_ProtocolVersion(unsigned versionNumber)
    {
        printf("\"protocol_version\":%u", versionNumber);
    }

    void Print_Metadata_CompanyName(UL_BOARD B)
    {
            /*
                Iterate over the board attributes looking for 'COMPANY'. If this attribute exists 
                it returns the value set for 'COMPANY' if set, otherwise returns an empty string.
            */
            string companyName = "";
            B.attributes(A)
            {
                if( (A.name == "COMPANY") )
                {
                    company = A.value;
                }
            }
            printf("\"company\":\"%s\"", companyName);
    }

    void Print_Metadata_ProjectRevision(void)
    {
        /*
            Iterate over the board attributes looking for 'REV' or 'REVISION'. If this attribute exists 
            it returns the value set for 'REV' or 'REVISION' if set, otherwise returns an empty string.
        */
        string revision = "";
        B.attributes(A)
        {
            if( (A.name == "REV") || (A.name == "REVISION"))
            {
                revision = A.value;
            }
        }
        printf(\"revision\":\"%s \"", revision);
    }

    void Print_Metadata_ECAD(void)
    {
        printf("\"ecad\":\"EAGLE\"");
    }

    void Print_Metadata_ProjectName(string pcbFileName)
    {
        // Used to hold the project name
        string projectName[];
        // filename(xxx) removes the directory part of the string if it exists. 
        // strsplit splits its input string by looking for '.' and puts the result in projectName
        int n = strsplit(projectName, filename(pcbFileName), '.');
        // The first element (at index 0), contains the filename.
        printf("\"project_name\":\"%s\"",projectName[0]);
    }

    void Print_Metadata_Date(void)
    {
        printf("\"date\":\"%s\"", t2string(time(), "Uyyyy-MM-dd hh:mm:ss"));
    }

    void Print_Metadata_NumberParts(void)
    {
        printf("\"number_parts\":{");
        Print_Metadata_NumberParts_Top();
        printf(",");
        Print_Metadata_NumberParts_Bottom();
        printf("}");
    }

    void Print_Metadata_NumberParts_Top(UL_BOARD B)
    {
        int partCount = 0;
        B.elements(E)
        {
            if(!E.mirror)
            {
                partCount = partCount + 1;
            }
        }
        printf("\"top\":%u", partCount);
    }

    void Print_Metadata_NumberParts_Bottom(UL_BOARD B)
    {
        int partCount = 0;
        B.elements(E)
        {
            if(E.mirror)
            {
                partCount = partCount + 1;
            }
        }
        printf("\"bottom\":%u", partCount);
    }

    void Print_Metadata( void )
    {
        board(B)
        {
            /*
                Print the metadata information to file. 
            */
            printf("\"metadata\":{");
            Print_Metadata_ProtocolVersion(PROTOCOL_VERSION);
            printf(",");
            Print_Metadata_ECAD(B);
            printf(",");
            Print_Metadata_CompanyName(void);
            printf(",");
            Print_Metadata_ProjectName(B.name)
            printf(",");
            Print_Metadata_ProjectRevision(void);
            printf(",");
            Print_Metadata_Date();
            printf(",");
            Print_Metadata_NumberParts(B);
            printf("},");
            printf("\n");
        }
    }
/**************************************************************************************************/

/**************************************************************************************************/
/********************                     BOARD DEFINITIONS                    ********************/
/**************************************************************************************************/
    void Print_Board_Traces_PCB_Trace(UL_SIGNAL S)
    {
        printf("{\"name\":\"%s\",\"segments\":[", S.name);
        int printedOnce = 0;
        S.wires(W)
        {
            if(printedOnce == 1)
            {
                printf(",");
            }
            if(W.arc)
            {
                // According to eagle documentation, output is always clockwise.
                Print_Segment_Path_Arc(layerNames[W.layer] ,u2mm(W.arc.xc), u2mm(W.arc.yc),  u2mm(W.arc.radius),  W.arc.angle1,  W.arc.angle2,  u2mm(W.width));
            }
            else
            {
                Print_Segment_Path_Line(layerNames[W.layer], u2mm(W.x1), u2mm(W.y1), u2mm(W.x2), u2mm(W.y2), u2mm(W.width));
            }
            printedOnce = 1;
        }
        int printedOnce = 0;
        S.vias(V)
        {
            if(printedOnce == 1)
            {
                printf(",");
            }
            if(V.shape[LAYER_TOP] ==  VIA_SHAPE_SQUARE)
            {
                Print_Segment_VIA_Round(layerNames[LAYER_VIAS],u2mm(V.x), u2mm(V.y), u2mm(V.diameter[LAYER_TOP]), u2mm(V.drill));
            }
            else if(V.shape[LAYER_TOP] ==  VIA_SHAPE_ROUND)
            {
                Print_Segment_VIA_Square(layerNames[LAYER_VIAS],u2mm(V.x), u2mm(V.y), u2mm(V.diameter[LAYER_TOP]), u2mm(V.drill));
            }
            // must be octagon
            else
            {
                Print_Segment_VIA_Octogon(layerNames[LAYER_VIAS],u2mm(V.x), u2mm(V.y), u2mm(V.diameter[LAYER_TOP]), u2mm(V.drill));
            }
            printedOnce = 1;
        }
        S.polygons(P)
        {
            if(printedOnce == 1)
            {
                printf(",");
            }

            printedOnce = 1;
        }
        printf("]");
        printf("}");
    }

    void Print_Board_Traces_PCB_Traces(void)
    {
        board(B)
        {
            int once_signal = 0;
            B.signals(S)
            {
                if(once_signal == 1)
                {
                    printf(",");
                }
                Print_Segment_Path_Polygon();
                once_signal = 1;
            }
        }
    }

    void Print_Board_Traces_PCB_Layer(UL_LAYER L)
    {
        printf("{\"name\":\"%s\",\"paths\":[",layerName);
        board(B)
        {
            int once = 0;
            B.texts(T)
            {
                if(T.layer == L.number)
                {
                    T.wires(W)
                    {
                        if(once == 1)
                        {
                            printf(",");
                        }
                        if(W.arc)
                        {
                            Print_Segment_Path_Arc(L.name, u2mm(W.arc.xc), u2mm(W.arc.yc),  u2mm(W.arc.radius), W.arc.angle1, W.arc.angle2, u2mm(W.width));
                        }
                        else
                        {
                            Print_Segment_Path_Line(L.name, u2mm(W.x1), u2mm(W.y1), u2mm(W.x2), u2mm(W.y2), u2mm(W.width));
                        }
                        once = 1;
                    }
                }
            }
            B.wires(W)
            {
                if(W.layer == L.number)
                {
                    if(once == 1)
                    {
                        printf(",");
                    }
                    if(W.arc)
                    {
                        Print_Segment_Path_Arc(L.name , u2mm(W.arc.xc), u2mm(W.arc.yc), u2mm(W.arc.radius), W.arc.angle1, W.arc.angle2, u2mm(W.width));
                    }
                    else
                    {
                        Print_Segment_Path_Line(L.name, u2mm(W.x1),  u2mm(W.y1), u2mm(W.x2), u2mm(W.y2), u2mm(W.width));
                    }
                    once = 1;
                }
            }
        }
        printf("]");
        printf("}");
    }

    void Print_Board_Traces_PCB_Layers(void)
    {
        board(B)
        {
            int firstLayer = 1;
            B.layers(L)
            {
                if(L.used)
                {
                    if(!firstLayer)
                    {
                        printf(",");
                    }
                    Print_Board_Traces_PCB_Layer(L);
                    firstLayer = 0;
                }
            }
        }
    }

    void Print_Board_Shape(void)
    {
        board(B)
        {
            Print_BoundingBox(u2mm(B.area.x1), u2mm(B.area.y1), u2mm(B.area.x2), u2mm(B.area.y2))
        }
    }

    void Print_Board_Traces(void)
    {
        printf("\"traces\":[");
        Print_Board_Traces_PCB_Traces();
        printf("]");
    }

    void Print_Board_Layers(void)
    {
        printf("\"layers\":" "[");
        Print_Board_Traces_PCB_Layers();
        printf("]");
    }

    void Print_Board( void )
    {
        printf("\"board\":{");
        Print_Board_Shape();
        printf(",");
        Print_Board_Traces();
        printf(",");
        Print_Board_Layers();
        printf("}");
    }
/**************************************************************************************************/

/**************************************************************************************************/
/********************                      PART DEFINITIONS                    ********************/
/**************************************************************************************************/

    
    <PART>        ::= "{" <PART_NAME> "," <PART_VALUE> "," <PART_PACKAGE> "," <PART_ATTRIBUTE> "," <PART_LOCATION> "}"

    <PART_NAME>            ::= "\"name\":"  "\"" <STRING> "\""
    <PART_VALUE>           ::= "\"value\":" "\"" <STRING> "\""
    <PART_PACKAGE>         ::= "\"package\":" "{" <PACKAGE_PADS> "," <PACKAGE_BOUNDING_BOX> "}"
    <PART_ATTRIBUTE>       ::= "\"attributes\":" "[" <ATTRIBUTES> "]"
    <PART_LOCATION>        ::= "\"location\":" <LOCATION>

    <LOCATION>  ::= "\"F\"" | "\"B\"" | "\"N\"" // F = Front, B = Back, N = Neither

    <ATTRIBUTES> ::= <ATTRIBUTE> | <ATTRIBUTE> "," <ATTRIBUTES>
    <ATTRIBUTE>  ::= "{" "\"name\":" "\"" <STRING> "\"" "," "\"value\":" "\"" <STRING> "\"" "}"


    <PACKAGE_PADS>         ::= "\"pads\":" "[" <PADS> "]"
    <PACKAGE_BOUNDING_BOX> ::= <BOUNDING_BOX>


    <PADS> ::= <PAD> | <PAD> "," <PADS>
    <PAD>  ::= <PAD_RECTANGLE> | <PAD_OBLONG> | <PAD_ROUND> | <PAD_OCTAGON> | <PAD_OFFSET>

    <PAD_RECTANGLE> ::= "{" "\"pad_type\":" <PAD_TYPE> "," "\"pin1\":" <PAD_PIN_ONE> "," "\"shape\":" "\"rect\""    "," "\"angle\":" <REAL_NUMBER> "," "\"x\":" <REAL_NUMBER> "," "\"y\":" <REAL_NUMBER> "," "\"dx\":" <REAL_NUMBER> "," "\"dy\":" <REAL_NUMBER> "," "\"drill\":" <REAL_NUMBER> "}"
    <PAD_OBLONG>    ::= "{" "\"pad_type\":" <PAD_TYPE> "," "\"pin1\":" <PAD_PIN_ONE> "," "\"shape\":" "\"oblong\""  "," "\"angle\":" <REAL_NUMBER> "," "\"x\":" <REAL_NUMBER> "," "\"y\":" <REAL_NUMBER> "," "\"diameter\":" <REAL_NUMBER> "," "\"elongation\":" <REAL_NUMBER> "," "\"drill\":" <REAL_NUMBER> "}"
    <PAD_ROUND>     ::= "{" "\"pad_type\":" <PAD_TYPE> "," "\"pin1\":" <PAD_PIN_ONE> "," "\"shape\":" "\"round\""   "," "\"angle\":" <REAL_NUMBER> "," "\"x\":" <REAL_NUMBER> "," "\"y\":" <REAL_NUMBER> "," "\"diameter\":" <REAL_NUMBER> "," "\"drill\":" <REAL_NUMBER>"}"
    <PAD_OCTAGON>   ::= "{" "\"pad_type\":" <PAD_TYPE> "," "\"pin1\":" <PAD_PIN_ONE> "," "\"shape\":" "\"round\""   "," "\"angle\":" <REAL_NUMBER> "," "\"x\":" <REAL_NUMBER> "," "\"y\":" <REAL_NUMBER> "," "\"diameter\":" <REAL_NUMBER> "," "\"drill\":" <REAL_NUMBER>"}"
    <PAD_OFFSET>    ::= "{" "\"pad_type\":" <PAD_TYPE> "," "\"pin1\":" <PAD_PIN_ONE> "," "\"shape\":" "\"oblong\""  "," "\"angle\":" <REAL_NUMBER> "," "\"x\":" <REAL_NUMBER> "," "\"y\":" <REAL_NUMBER> "," "\"diameter\":" <REAL_NUMBER> "," "\"elongation\":" <REAL_NUMBER> "," "\"drill\":" <REAL_NUMBER> "}"

    

    <PAD_TYPE>    ::= "\"smd\""  | "\"tht\""
    <PAD_PIN_ONE> ::= "1" | "0" //  1 = Yes, 0 = No
    <PAD_SHAPE>   ::= "\"rect\"" | "\"octagon\"" | "\"oblong\"" | "\"circle\""


void Print_Part_Entry(void)
{
    <PARTS_ENTRY> ::= <PART> | <PART> "," <PARTS_ENTRY>
}


void Pint_Part(void)
{
    printf("\"parts\":" "[");
    Print_Part_Entry();
    printf("]");
}


/**************************************************************************************************/

/**************************************************************************************************/
/********************                  CONFIGURATION DEFINITIONS               ********************/
/**************************************************************************************************/
void Print_Configuration()
{
    printf("\"configuration\": [");

    board(B)
    {
        int firstLayer = 1;
        B.layers(L)
        {
            if(L.used)
            {
                if(!firstLayer)
                {
                    printf(",");
                }
                printf( "{\"category\":\"%s\",\"name\":\"%s\",\"value\":\"%s\"}"
                        ,"color"
                        ,L.name
                        ,PalletColorToHTMLString(palette(L.color))
                      );
                firstLayer = 0;
            }
        }
    }
    printf("]");
}
/**************************************************************************************************/

void PrintPads(UL_ELEMENT E)
{
    int first = 1;
    printf("\"pads\": [");

    E.package.contacts(C)
    {
        if (!first)
        {   
            printf(",");
        }

        printf("{");

        // Surface mount or through hole
        if(C.smd)
        {
            printf("\"pad_type\":\"smd\",");
        }
        else
        {
            printf("\"pad_type\":\"tht\",");
        }

        // Pin 1
        if(C.name=="1")
        {
            // Yes
           printf("\"pin1\":1,");
        }
        else
        {
            // No
            printf("\"pin1\":0,");
        }

        /* Set shape */
        if(C.smd)
        {
            printf("\"shape\":\"rect\",");
            printf("\"angle\":%5.5f,",C.smd.angle);
            printf("\"x\":%5.5f,"    , u2mm(C.smd.x) );
            printf("\"y\":%5.5f,"    , u2mm(C.smd.y) );
            printf("\"dx\":%5.5f,"   , u2mm(C.smd.dx));
            printf("\"dy\":%5.5f"    , u2mm(C.smd.dy));
        }
        else
        {
            if(C.pad.shape[LAYER_TOP] == PAD_SHAPE_SQUARE)
            {
                printf("\"shape\":\"rect\",");
                printf("\"angle\":%5.5f," ,C.pad.angle);
                printf("\"x\":%5.5f,"     , u2mm(C.pad.x) );
                printf("\"y\":%5.5f,"     , u2mm(C.pad.y) );
                printf("\"dx\":%5.5f,"    , u2mm(C.pad.diameter[LAYER_TOP]));
                printf("\"dy\":%5.5f,"    , u2mm(C.pad.diameter[LAYER_TOP]));
                printf("\"drill\":%5.5f"  , u2mm(C.pad.drill) );
            }
            else if(C.pad.shape[LAYER_TOP] == PAD_SHAPE_ROUND)
            {
                printf("\"shape\":\"round\",");
                printf("\"angle\":%5.5f,"      ,C.pad.angle);
                printf("\"x\":%5.5f,"          , u2mm(C.pad.x) );
                printf("\"y\":%5.5f,"          , u2mm(C.pad.y) );
                printf("\"elongation\":%d,"    , C.pad.elongation );
                printf("\"drill\":%5.5f"       , u2mm(C.pad.drill) );
            }
            else if(C.pad.shape[LAYER_TOP] == PAD_SHAPE_OCTAGON)
            {
                printf("\"shape\":\"octagon\",");
                printf("\"angle\":%5.5f,"      ,C.pad.angle);
                printf("\"x\":%5.5f,"          , u2mm(C.pad.x) );
                printf("\"y\":%5.5f,"          , u2mm(C.pad.y) );
                printf("\"diameter\":%5.5f,"  , u2mm(C.pad.diameter[LAYER_TOP]) );
                printf("\"elongation\":%d,"    , C.pad.elongation );
                printf("\"drill\":%5.5f"       ,u2mm(C.pad.drill) );
            }
            else if(C.pad.shape[LAYER_TOP] == PAD_SHAPE_LONG)
            {
                printf("\"shape\":\"oblong\",");
                printf("\"angle\":%5.5f,"     ,C.pad.angle);
                printf("\"x\":%5.5f,"         , u2mm(C.pad.x));
                printf("\"y\":%5.5f,"         , u2mm(C.pad.y));
                printf("\"diameter\":%5.5f,"  , u2mm(C.pad.diameter[LAYER_TOP]) );
                printf("\"elongation\":%d,"   , C.pad.elongation);
                printf("\"drill\":%5.5f"      ,u2mm(C.pad.drill));
            }
            else if(C.pad.shape[LAYER_TOP] == PAD_SHAPE_OFFSET)
            {
                printf("\"shape\":\"offset\",");
                printf("\"angle\":%5.5f,"     , C.pad.angle);
                printf("\"x\":%5.5f,"         , u2mm(C.pad.x) );
                printf("\"y\":%5.5f,"         , u2mm(C.pad.y) );
                printf("\"diameter\":%5.5f,"  , u2mm(C.pad.diameter[LAYER_TOP]) );
                printf("\"elongation\":%d,"   , C.pad.elongation );
                printf("\"drill\":%5.5f"      , u2mm(C.pad.drill) );
            }
            else
            {

            }
        }
        printf("}");
        first = 0;
    }
    printf("]");
}



/*
DESCRIPTION: Scans a string and replaces douple quotes (") with a space character. This is needed
             so that the resulting JSON file is valid. Without this check the resulting JSON
             could include double quotes embedded in a  part and the resulting JSON is invalid
             which will make iPCB not work. 
*/
string removeDoubleQuote(string passedString)
{
    for (int i = 0; passedString[i]; ++i) 
    {    
        if(passedString[i] == '\"')
        {
            passedString[i] = ' ';
        }
    }
    return passedString;
}


void PrintPackageBoundingBox(UL_ELEMENT E)
{
    // Print the edge_box segment to the output file
    printf("\"bounding_box\":{");
    printf("\"x0\":%5.5f,", u2mm(E.package.area.x1));
    printf("\"y0\":%5.5f,", u2mm(E.package.area.y1));
    printf("\"x1\":%5.5f,", u2mm(E.package.area.x2));
    printf("\"y1\":%5.5f" , u2mm(E.package.area.y2));
    printf("}");
}

void GeneratePCBEdges( void )
{
    int once = 0;
    printf("\"edges\":[");
    // Iterate over every wire on the pcb board. 
    board(B)
    {
        B.wires(W)
        {
            /* 
                Check if the wire is on the dimension layer. If the wire is on the dimension layer then
                add a segment object to the output file. 

                The start and end points of the wire segment need to be converted to be in millimeters.
                The type will always be set to segment since the assumption is that the board dimension
                is set using wire segments.

                The widths is the size of the wire.
            */
            if(W.layer == LAYER_DIMENSION)
            {
                if(once == 1)
                {
                    printf(",");
                }
                if(W.arc)
                {
                    // According to eagle documentation, output is always clockwise. 
                    PrintPathType_Arc(layerNames[W.layer] , u2mm(W.arc.xc), u2mm(W.arc.yc),  u2mm(W.arc.radius),  W.arc.angle1,  W.arc.angle2,  u2mm(W.width));
                }
                else
                {
                    PrintPathType_Line(layerNames[W.layer] , u2mm(W.x1),  u2mm(W.y1),  u2mm(W.x2),  u2mm(W.y2),  u2mm(W.width));
                }
                once = 1;
            }
        }
    }
    printf("]");
}
/*
    Add the section for the bounding box. The bounding box is created by looking at the min and max 
    x and y values for the board. The min and max values are defined as the lower left and upper 
    right points that form a box that encapsulates the entire pcb. 
*/
void GeneratePCBShape( void )
{
    board(B) {
        // Print to the file the start of the edges section. This will be an array of wire segments
        GeneratePCBBoundingBox();
        printf("\n");
    }
}


void PrintPartData()
{
    int firstPart = 1;
    board(B) 
    {
        B.elements(E)
        {
            if(!firstPart)
            {
                printf(",");
            }
            printf("{");
            printf("\"name\":\"%s\"," , removeDoubleQuote(E.name));
            printf("\"value\":\"%s\",", removeDoubleQuote(E.value));

            /**************************************************************************************/
            // package
            printf("\"package\":{");
            PrintPads(E);
            printf(",");
            PrintPackageBoundingBox(E);
            printf("},");
            /**********************************************************************************/

            /**************************************************************************************/
            // Attributes
            numeric string attributeName;
            numeric string attributeValue;
            E.attributes(A)
            {
                attributeName += removeDoubleQuote(A.name) + ";";
                attributeValue += removeDoubleQuote(A.value) + ";";
            }
            
            attributeName += "footprint" + ";";
            attributeValue += E.footprint.name + ";";

            // This removes the trailing ;
            if(strlen(attributeName) > 0)
            {
                attributeName[strlen(attributeName)-1] = 0;
            }
            else
            {
                attributeName[0] = 0;
            }

            // This removes the trailing ;
            if(strlen(attributeValue) > 0)
            {
                attributeValue[strlen(attributeValue)-1] = 0;
            }
            else
            {
                attributeValue[0] = 0;
            }


            printf("\"attributes\":{\n");
            printf("\"name\":\"%s\","  , attributeName);
            printf("\"value\":\"%s\"" , attributeValue);
            printf("},");
            /**************************************************************************************/
            // Location
            if(!E.mirror)
            {
                printf("\"location\":\"F\"");
            }
            else
            {
                printf("\"location\":\"B\"");
            }

            printf("}");
            firstPart = 0;
        }
    }
}

void GenerateParts( void )
{
    printf("\"parts\":[");
    PrintPartData();
    printf("]");
}

/**************************************************************************************************/




output(outputFileName,"wt")
{
     board(B)
    {
        B.layers(L)
        {
            layerNames[L.number] = L.name;
        }
    }

    printf("var pcbdata =  {\n");
    Print_Metadata();
    printf(",")
    Print_Board();
    printf(",");
    Print_Parts();
    printf(",");
    Print_Configuration();
    printf("}");
}
